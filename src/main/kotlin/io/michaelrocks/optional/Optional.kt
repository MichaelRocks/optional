/*
 * Copyright (C) 2016 Michael Rozumyanskiy
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.michaelrocks.optional

import java.util.ArrayList
import java.util.HashSet
import java.util.NoSuchElementException
import java.util.SortedSet
import java.util.TreeSet

/** A class that may contain a single value. */
sealed class Optional<out T : Any> {
  /** An [Optional] that contains a value. */
  class Some<out T : Any>(val value: T) : Optional<T>() {
    override fun equals(other: Any?): Boolean {
      if (this === other) {
        return true
      }

      @Suppress("UNCHECKED_CAST")
      val that = other as? Some<T> ?: return false
      return value == that.value
    }

    override fun hashCode(): Int {
      return value.hashCode()
    }

    override fun toString(): String {
      return "Some($value)"
    }
  }

  /** An [Optional] that doesn't contain a value. */
  object None : Optional<Nothing>() {
    override fun toString(): String {
      return "None"
    }
  }
}

/** @return `true` if the [Optional] contains a value, `false` otherwise. */
val Optional<*>.isSome: Boolean
  get() = this is Optional.Some
/** @return `true` if the [Optional] doesn't contain a value, `true` otherwise. */
val Optional<*>.isNone: Boolean
  get() = this is Optional.None

/** @return An [Optional] with the given [value] */
fun <T : Any> some(value: T): Optional<T> {
  return Optional.Some(value)
}

/** An [Optional] without a value. */
fun none(): Optional<Nothing> {
  return Optional.None
}

/** An [Optional] of type [T] without a value. */
fun <T : Any> noneOfType(): Optional<T> {
  return Optional.None
}

/**
 * @return A contained value.
 * @throws [NoSuchElementException] if the [Optional] contains no value.
 */
fun <T : Any> Optional<T>.get(): T {
  return getOrNull() ?: throw NoSuchElementException("Optional.None doesn't contain a value")
}

/** @return A contained value, or `null` if the [Optional] contains no value. */
fun <T : Any> Optional<T>.getOrNull(): T? {
  return when (this) {
    is Optional.Some -> value
    else -> null
  }
}

/** @return A contained value, or invokes [defaultValue] and returns its result if the [Optional] contains no value. */
fun <T : Any> Optional<T>.getOrElse(defaultValue: () -> T): T {
  return getOrNull() ?: defaultValue()
}

/**
 * @return A contained value if it matches the given [predicate].
 * @throws [NoSuchElementException] if the [Optional] contains no value, or if the contained value doesn't match the given [predicate].
 */
inline fun <T : Any> Optional<T>.getIf(predicate: (T) -> Boolean): T {
  return getIfOrNull(predicate)
      ?: throw NoSuchElementException("Optional.None doesn't contain a value that matches the given predicate")
}

/** @return A contained value if it matches the given [predicate], or `null` if the [Optional] contains no value, or if the contained value doesn't match the given [predicate]. */
inline fun <T : Any> Optional<T>.getIfOrNull(predicate: (T) -> Boolean): T? {
  return getOrNull()?.let { value ->
    if (predicate(value)) value else null
  }
}

/** @return An [Optional] containing a value matching the given [predicate], or [Optional.None] otherwise. */
inline fun <T : Any> Optional<T>.filter(predicate: (T) -> Boolean): Optional<T> {
  return getIfOrNull(predicate).toOptional()
}

/** @return An [Optional] containing a value not matching the given [predicate], or [Optional.None] otherwise. */
inline fun <T : Any> Optional<T>.filterNot(predicate: (T) -> Boolean): Optional<T> {
  return filter { !predicate(it) }
}

/** @return An [Optional] containing a value that is an instance of specified class, or [Optional.None] otherwise. */
inline fun <reified R : Any> Optional<*>.filterIsInstance(): Optional<R> {
  return mapNotNull { it as? R }
}

/** @return An [Optional] containing a value that is an instance of specified class, or [Optional.None] otherwise. */
fun <R : Any> Optional<*>.filterIsInstance(klass: Class<R>): Optional<R> {
  return mapNotNull {
    if (klass.isInstance(it)) klass.cast(it) else null
  }
}

/** @return An [Optional] yielded from a result of [transform] function being invoked on a value of the [Optional]. */
inline fun <T : Any, R : Any> Optional<T>.flatMap(transform: (T) -> Optional<R>): Optional<R> {
  return getOrNull()?.let { transform(it) } ?: Optional.None
}

/** @return An [Optional] with a value generated by applying the given [transform] function to a value of the [Optional]. */
inline fun <T : Any, R : Any> Optional<T>.map(transform: (T) -> R): Optional<R> {
  return mapNotNull(transform)
}

/** @return An [Optional] with a non-`null` value generated by applying the given [transform] function to a value of the [Optional]. */
inline fun <T : Any, R : Any> Optional<T>.mapNotNull(transform: (T) -> R?): Optional<R> {
  return getOrNull()?.let { transform(it) }.toOptional()
}

/** @return The original [Optional] if it contains a value, or an [Optional] returned by the given [generator] function otherwise. */
inline fun <T : Any> Optional<T>.switchIfNone(generator: () -> Optional<T>): Optional<T> {
  return when (this) {
    is Optional.Some -> this
    is Optional.None -> generator()
  }
}

/** @return `true` if [Optional]'s value matches the given [predicate], `false` otherwise. */
inline fun <T : Any> Optional<T>.matches(predicate: (T) -> Boolean): Boolean {
  return getOrNull()?.let { predicate(it) } ?: false
}

/** @return `true` if [Optional]'s value matches the given [predicate] or it contains no value, `false` otherwise. */
inline fun <T : Any> Optional<T>.matchesOrNone(predicate: (T) -> Boolean): Boolean {
  return getOrNull()?.let { predicate(it) } ?: true
}

/** @return A result of the given [operation] applied to [initial] and [Optional]'s value, or [initial] if the [Optional] contains no value. */
inline fun <T : Any, R : Any> Optional<T>.fold(initial: R, operation: (R, T) -> R): R {
  return getOrNull()?.let { operation(initial, it) } ?: initial
}

/** Performs the given [action] on a value of the [Optional]. */
inline fun <T : Any> Optional<T>.forEach(action: (T) -> Unit): Unit {
  getOrNull()?.let { action(it) }
}

/** @return An [Optional] that contains a result of the given [transform] function applied to both [Optional]'s values, or either of the [Optional]s if one of them doesn't contain a value. */
inline fun <T : Any> Optional<T>.combine(other: Optional<T>, transform: (T, T) -> T): Optional<T> {
  val value1 = getOrNull() ?: return other
  val value2 = other.getOrNull() ?: return this
  return Optional.Some(transform(value1, value2))
}

/**
 * Splits the original [Optional] into a pair of [Optional]s
 * where the *first* [Optional] contains a value if the [predicate] returns `true`,
 * while the *second* [Optional] contains a value if the [predicate] returns `false`.
 */
inline fun <T : Any> Optional<T>.partition(predicate: (T) -> Boolean): Pair<Optional<T>, Optional<T>> {
  return getOrNull()?.let {
    if (predicate(it)) {
      Pair(this, Optional.None)
    } else {
      Pair(Optional.None, this)
    }
  } ?: Pair(Optional.None, Optional.None)
}

/** @return An [Optional] that contains a [Pair] of [Optional]s' values if they both contain values, or [Optional.None] otherwise. */
infix fun <T : Any, R : Any> Optional<T>.zip(other: Optional<R>): Optional<Pair<T, R>> {
  return zip(other) { t1, t2 -> Pair(t1, t2) }
}

/** @return An [Optional] that contains a result of the [transform] function applied to [Optional]s' values if they both contain values, or [Optional.None] otherwise. */
inline fun <T : Any, R : Any, V : Any> Optional<T>.zip(other: Optional<R>, transform: (T, R) -> V): Optional<V> {
  val value1 = getOrNull() ?: return Optional.None
  val value2 = other.getOrNull() ?: return Optional.None
  return Optional.Some(transform(value1, value2))
}

/** Appends a value if it exists to the given [collection]. */
fun <T : Any, C : MutableCollection<in T>> Optional<T>.toCollection(collection: C): C {
  getOrNull()?.let { collection.add(it) }
  return collection
}

/** @return A [List] with a value of the [Optional]. */
fun <T : Any> Optional<T>.toList(): List<T> {
  return getOrNull()?.let { listOf(it) } ?: emptyList()
}

/** @return A [MutableList] with a value of the [Optional]. */
fun <T : Any> Optional<T>.toMutableList(): MutableList<T> {
  return toCollection(ArrayList<T>(1))
}

/** @return A [Set] with a value of the [Optional]. */
fun <T : Any> Optional<T>.toSet(): Set<T> {
  return getOrNull()?.let { setOf(it) } ?: emptySet()
}

/** @return A [HashSet] with a value of the [Optional]. */
fun <T : Any> Optional<T>.toHashSet(): HashSet<T> {
  return toCollection(HashSet<T>(1))
}

/** @return A [SortedSet] with a value of the [Optional]. */
fun <T : Comparable<T>> Optional<T>.toSortedSet(): SortedSet<T> {
  return toCollection(TreeSet<T>())
}

/** @return An [Iterable] with a value of the [Optional], or an empty [Iterable] if the [Optional] contains no value. */
fun <T : Any> Optional<T>.asIterable(): Iterable<T> {
  return toList()
}

/** @return An [Sequence] with a value of the [Optional], or an empty [Iterable] if the [Optional] contains no value. */
fun <T : Any> Optional<T>.asSequence(): Sequence<T> {
  return Sequence { asIterable().iterator() }
}

/** @return [Optional.Some] with the receiver if its not `null`, [Optional.None] otherwise. */
fun <T : Any> T?.toOptional(): Optional<T> {
  return this?.let { Optional.Some(it) } ?: Optional.None
}
